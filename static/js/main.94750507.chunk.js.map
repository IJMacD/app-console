{"version":3,"sources":["../../node_modules/babel-plugin-transform-async-to-promises/helpers.js","../../src/shell.js","../../src/console.jsx","App.js","serviceWorker.js","index.js"],"names":["_Pact","prototype","then","onFulfilled","onRejected","result","state","this","s","callback","_settle","v","e","o","_this","value","pact","bind","observer","_isSettledPact","thenable","Symbol","iterator","asyncIterator","_for","test","update","body","stage","shouldContinue","updateValue","reject","_resumeAfterTest","_resumeAfterBody","_resumeAfterUpdate","_catch","recover","executeCommand","command","evaldArgs","context","executables","Error","setVariable","name","variables","getVariable","BUILTINS","Object","run","statement","args","Promise","arg","left","ver","process","require","help","commands","cmds","Set","Array","get","set","date","type","sleep","n","r","setTimeout","echo","a","cast","t","toString","length","json","JSON","range","grep","re","RegExp","index","tee","options","variable","append","newVal","eval","input","tokens","tokenise","statements","parse","alert","CONTROL","OPERATORS","Shell","execute","output","error","executeStatements","i","originalItem","start","items","iteration","loopVar","doneIndex","forLoop","executeStatementOperator","self","originalContext","promise","executeStatement","String","matchers","regex","text","tail","done","m","match","val","repeat","splitTokens","parseStatementOperators","background","prev","curr","operator","right","joinStatementOperators","makeNode","control","parseStatement","pipes","end","item","str","joinPipes","out","current","isNotNull","isNull","ConsoleDisplay","shell","style","onClose","React","hist","setHist","setInput","scrollback","setScrollback","executing","setExecuting","inputRef","shellRef","outerRef","textColor","setTextColor","backgroundColor","setBackgroundColor","exit","clear","handleSubmit","pushHist","divStyle","height","color","className","classes","ref","onClick","getSelection","key","l","onSubmit","disabled","onChange","onKeyUp","inputHist","h","nextScrollback","Math","isNaN","onKeyDown","autoFocus","demo","App","Boolean","window","location","hostname","ReactDOM","render","StrictMode","document","getElementById","navigator","serviceWorker","ready","registration","unregister","catch","console","message"],"mappings":"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","file":"static/js/main.94750507.chunk.js","sourcesContent":["// A type of promise-like that resolves synchronously and supports only one observer\nexport const _Pact = /*#__PURE__*/(function() {\n\tfunction _Pact() {}\n\t_Pact.prototype.then = function(onFulfilled, onRejected) {\n\t\tconst result = new _Pact();\n\t\tconst state = this.s;\n\t\tif (state) {\n\t\t\tconst callback = state & 1 ? onFulfilled : onRejected;\n\t\t\tif (callback) {\n\t\t\t\ttry {\n\t\t\t\t\t_settle(result, 1, callback(this.v));\n\t\t\t\t} catch (e) {\n\t\t\t\t\t_settle(result, 2, e);\n\t\t\t\t}\n\t\t\t\treturn result;\n\t\t\t} else {\n\t\t\t\treturn this;\n\t\t\t}\n\t\t}\n\t\tthis.o = function(_this) {\n\t\t\ttry {\n\t\t\t\tconst value = _this.v;\n\t\t\t\tif (_this.s & 1) {\n\t\t\t\t\t_settle(result, 1, onFulfilled ? onFulfilled(value) : value);\n\t\t\t\t} else if (onRejected) {\n\t\t\t\t\t_settle(result, 1, onRejected(value));\n\t\t\t\t} else {\n\t\t\t\t\t_settle(result, 2, value);\n\t\t\t\t}\n\t\t\t} catch (e) {\n\t\t\t\t_settle(result, 2, e);\n\t\t\t}\n\t\t};\n\t\treturn result;\n\t}\n\treturn _Pact;\n})();\n\n// Settles a pact synchronously\nexport function _settle(pact, state, value) {\n\tif (!pact.s) {\n\t\tif (value instanceof _Pact) {\n\t\t\tif (value.s) {\n\t\t\t\tif (state & 1) {\n\t\t\t\t\tstate = value.s;\n\t\t\t\t}\n\t\t\t\tvalue = value.v;\n\t\t\t} else {\n\t\t\t\tvalue.o = _settle.bind(null, pact, state);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tif (value && value.then) {\n\t\t\tvalue.then(_settle.bind(null, pact, state), _settle.bind(null, pact, 2));\n\t\t\treturn;\n\t\t}\n\t\tpact.s = state;\n\t\tpact.v = value;\n\t\tconst observer = pact.o;\n\t\tif (observer) {\n\t\t\tobserver(pact);\n\t\t}\n\t}\n}\n\nexport function _isSettledPact(thenable) {\n\treturn thenable instanceof _Pact && thenable.s & 1;\n}\n\n// Converts argument to a function that always returns a Promise\nexport function _async(f) {\n\treturn function() {\n\t\tfor (var args = [], i = 0; i < arguments.length; i++) {\n\t\t\targs[i] = arguments[i];\n\t\t}\n\t\ttry {\n\t\t\treturn Promise.resolve(f.apply(this, args));\n\t\t} catch(e) {\n\t\t\treturn Promise.reject(e);\n\t\t}\n\t}\n}\n\n// Awaits on a value that may or may not be a Promise (equivalent to the await keyword in ES2015, with continuations passed explicitly)\nexport function _await(value, then, direct) {\n\tif (direct) {\n\t\treturn then ? then(value) : value;\n\t}\n\tif (!value || !value.then) {\n\t\tvalue = Promise.resolve(value);\n\t}\n\treturn then ? value.then(then) : value;\n}\n\n// Awaits on a value that may or may not be a Promise, then ignores it\nexport function _awaitIgnored(value, direct) {\n\tif (!direct) {\n\t\treturn value && value.then ? value.then(_empty) : Promise.resolve();\n\t}\n}\n\n// Proceeds after a value has resolved, or proceeds immediately if the value is not thenable\nexport function _continue(value, then) {\n\treturn value && value.then ? value.then(then) : then(value);\n}\n\n// Proceeds after a value has resolved, or proceeds immediately if the value is not thenable\nexport function _continueIgnored(value) {\n\tif (value && value.then) {\n\t\treturn value.then(_empty);\n\t}\n}\n\n// Asynchronously iterate through an object that has a length property, passing the index as the first argument to the callback (even as the length property changes)\nexport function _forTo(array, body, check) {\n\tvar i = -1, pact, reject;\n\tfunction _cycle(result) {\n\t\ttry {\n\t\t\twhile (++i < array.length && (!check || !check())) {\n\t\t\t\tresult = body(i);\n\t\t\t\tif (result && result.then) {\n\t\t\t\t\tif (_isSettledPact(result)) {\n\t\t\t\t\t\tresult = result.v;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tresult.then(_cycle, reject || (reject = _settle.bind(null, pact = new _Pact(), 2)));\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (pact) {\n\t\t\t\t_settle(pact, 1, result);\n\t\t\t} else {\n\t\t\t\tpact = result;\n\t\t\t}\n\t\t} catch (e) {\n\t\t\t_settle(pact || (pact = new _Pact()), 2, e);\n\t\t}\n\t}\n\t_cycle();\n\treturn pact;\n}\n\n// Asynchronously iterate through an object's properties (including properties inherited from the prototype)\n// Uses a snapshot of the object's properties\nexport function _forIn(target, body, check) {\n\tvar keys = [];\n\tfor (var key in target) {\n\t\tkeys.push(key);\n\t}\n\treturn _forTo(keys, function(i) { return body(keys[i]); }, check);\n}\n\n// Asynchronously iterate through an object's own properties (excluding properties inherited from the prototype)\n// Uses a snapshot of the object's properties\nexport function _forOwn(target, body, check) {\n\tvar keys = [];\n\tfor (var key in target) {\n\t\tif (Object.prototype.hasOwnProperty.call(target, key)) {\n\t\t\tkeys.push(key);\n\t\t}\n\t}\n\treturn _forTo(keys, function(i) { return body(keys[i]); }, check);\n}\n\nexport const _iteratorSymbol = /*#__PURE__*/ typeof Symbol !== \"undefined\" ? (Symbol.iterator || (Symbol.iterator = Symbol(\"Symbol.iterator\"))) : \"@@iterator\";\n\n// Asynchronously iterate through an object's values\n// Uses for...of if the runtime supports it, otherwise iterates until length on a copy\nexport function _forOf(target, body, check) {\n\tif (typeof target[_iteratorSymbol] === \"function\") {\n\t\tvar iterator = target[_iteratorSymbol](), step, pact, reject;\n\t\tfunction _cycle(result) {\n\t\t\ttry {\n\t\t\t\twhile (!(step = iterator.next()).done && (!check || !check())) {\n\t\t\t\t\tresult = body(step.value);\n\t\t\t\t\tif (result && result.then) {\n\t\t\t\t\t\tif (_isSettledPact(result)) {\n\t\t\t\t\t\t\tresult = result.v;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tresult.then(_cycle, reject || (reject = _settle.bind(null, pact = new _Pact(), 2)));\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (pact) {\n\t\t\t\t\t_settle(pact, 1, result);\n\t\t\t\t} else {\n\t\t\t\t\tpact = result;\n\t\t\t\t}\n\t\t\t} catch (e) {\n\t\t\t\t_settle(pact || (pact = new _Pact()), 2, e);\n\t\t\t}\n\t\t}\n\t\t_cycle();\n\t\tif (iterator.return) {\n\t\t\tvar _fixup = function(value) {\n\t\t\t\ttry {\n\t\t\t\t\tif (!step.done) {\n\t\t\t\t\t\titerator.return();\n\t\t\t\t\t}\n\t\t\t\t} catch(e) {\n\t\t\t\t}\n\t\t\t\treturn value;\n\t\t\t}\n\t\t\tif (pact && pact.then) {\n\t\t\t\treturn pact.then(_fixup, function(e) {\n\t\t\t\t\tthrow _fixup(e);\n\t\t\t\t});\n\t\t\t}\n\t\t\t_fixup();\n\t\t}\n\t\treturn pact;\n\t}\n\t// No support for Symbol.iterator\n\tif (!(\"length\" in target)) {\n\t\tthrow new TypeError(\"Object is not iterable\");\n\t}\n\t// Handle live collections properly\n\tvar values = [];\n\tfor (var i = 0; i < target.length; i++) {\n\t\tvalues.push(target[i]);\n\t}\n\treturn _forTo(values, function(i) { return body(values[i]); }, check);\n}\n\nexport const _asyncIteratorSymbol = /*#__PURE__*/ typeof Symbol !== \"undefined\" ? (Symbol.asyncIterator || (Symbol.asyncIterator = Symbol(\"Symbol.asyncIterator\"))) : \"@@asyncIterator\";\n\n// Asynchronously iterate on a value using it's async iterator if present, or its synchronous iterator if missing\nexport function _forAwaitOf(target, body, check) {\n\tif (typeof target[_asyncIteratorSymbol] === \"function\") {\n\t\tvar pact = new _Pact();\n\t\tvar iterator = target[_asyncIteratorSymbol]();\n\t\titerator.next().then(_resumeAfterNext).then(void 0, _reject);\n\t\treturn pact;\n\t\tfunction _resumeAfterBody(result) {\n\t\t\tif (check && check()) {\n\t\t\t\treturn _settle(pact, 1, iterator.return ? iterator.return().then(function() { return result; }) : result);\n\t\t\t}\n\t\t\titerator.next().then(_resumeAfterNext).then(void 0, _reject);\n\t\t}\n\t\tfunction _resumeAfterNext(step) {\n\t\t\tif (step.done) {\n\t\t\t\t_settle(pact, 1);\n\t\t\t} else {\n\t\t\t\tPromise.resolve(body(step.value)).then(_resumeAfterBody).then(void 0, _reject);\n\t\t\t}\n\t\t}\n\t\tfunction _reject(error) {\n\t\t\t_settle(pact, 2, iterator.return ? iterator.return().then(function() { return error; }) : error);\n\t\t}\n\t}\n\treturn Promise.resolve(_forOf(target, function(value) { return Promise.resolve(value).then(body); }, check));\n}\n\n// Asynchronously implement a generic for loop\nexport function _for(test, update, body) {\n\tvar stage;\n\tfor (;;) {\n\t\tvar shouldContinue = test();\n\t\tif (_isSettledPact(shouldContinue)) {\n\t\t\tshouldContinue = shouldContinue.v;\n\t\t}\n\t\tif (!shouldContinue) {\n\t\t\treturn result;\n\t\t}\n\t\tif (shouldContinue.then) {\n\t\t\tstage = 0;\n\t\t\tbreak;\n\t\t}\n\t\tvar result = body();\n\t\tif (result && result.then) {\n\t\t\tif (_isSettledPact(result)) {\n\t\t\t\tresult = result.s;\n\t\t\t} else {\n\t\t\t\tstage = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (update) {\n\t\t\tvar updateValue = update();\n\t\t\tif (updateValue && updateValue.then && !_isSettledPact(updateValue)) {\n\t\t\t\tstage = 2;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tvar pact = new _Pact();\n\tvar reject = _settle.bind(null, pact, 2);\n\t(stage === 0 ? shouldContinue.then(_resumeAfterTest) : stage === 1 ? result.then(_resumeAfterBody) : updateValue.then(_resumeAfterUpdate)).then(void 0, reject);\n\treturn pact;\n\tfunction _resumeAfterBody(value) {\n\t\tresult = value;\n\t\tdo {\n\t\t\tif (update) {\n\t\t\t\tupdateValue = update();\n\t\t\t\tif (updateValue && updateValue.then && !_isSettledPact(updateValue)) {\n\t\t\t\t\tupdateValue.then(_resumeAfterUpdate).then(void 0, reject);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t\tshouldContinue = test();\n\t\t\tif (!shouldContinue || (_isSettledPact(shouldContinue) && !shouldContinue.v)) {\n\t\t\t\t_settle(pact, 1, result);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (shouldContinue.then) {\n\t\t\t\tshouldContinue.then(_resumeAfterTest).then(void 0, reject);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tresult = body();\n\t\t\tif (_isSettledPact(result)) {\n\t\t\t\tresult = result.v;\n\t\t\t}\n\t\t} while (!result || !result.then);\n\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t}\n\tfunction _resumeAfterTest(shouldContinue) {\n\t\tif (shouldContinue) {\n\t\t\tresult = body();\n\t\t\tif (result && result.then) {\n\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t} else {\n\t\t\t\t_resumeAfterBody(result);\n\t\t\t}\n\t\t} else {\n\t\t\t_settle(pact, 1, result);\n\t\t}\n\t}\n\tfunction _resumeAfterUpdate() {\n\t\tif (shouldContinue = test()) {\n\t\t\tif (shouldContinue.then) {\n\t\t\t\tshouldContinue.then(_resumeAfterTest).then(void 0, reject);\n\t\t\t} else {\n\t\t\t\t_resumeAfterTest(shouldContinue);\n\t\t\t}\n\t\t} else {\n\t\t\t_settle(pact, 1, result);\n\t\t}\n\t}\n}\n\n// Asynchronously implement a do ... while loop\nexport function _do(body, test) {\n\tvar awaitBody;\n\tdo {\n\t\tvar result = body();\n\t\tif (result && result.then) {\n\t\t\tif (_isSettledPact(result)) {\n\t\t\t\tresult = result.v;\n\t\t\t} else {\n\t\t\t\tawaitBody = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tvar shouldContinue = test();\n\t\tif (_isSettledPact(shouldContinue)) {\n\t\t\tshouldContinue = shouldContinue.v;\n\t\t}\n\t\tif (!shouldContinue) {\n\t\t\treturn result;\n\t\t}\n\t} while (!shouldContinue.then);\n\tconst pact = new _Pact();\n\tconst reject = _settle.bind(null, pact, 2);\n\t(awaitBody ? result.then(_resumeAfterBody) : shouldContinue.then(_resumeAfterTest)).then(void 0, reject);\n\treturn pact;\n\tfunction _resumeAfterBody(value) {\n\t\tresult = value;\n\t\tfor (;;) {\n\t\t\tshouldContinue = test();\n\t\t\tif (_isSettledPact(shouldContinue)) {\n\t\t\t\tshouldContinue = shouldContinue.v;\n\t\t\t}\n\t\t\tif (!shouldContinue) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (shouldContinue.then) {\n\t\t\t\tshouldContinue.then(_resumeAfterTest).then(void 0, reject);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tresult = body();\n\t\t\tif (result && result.then) {\n\t\t\t\tif (_isSettledPact(result)) {\n\t\t\t\t\tresult = result.v;\n\t\t\t\t} else {\n\t\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t_settle(pact, 1, result);\n\t}\n\tfunction _resumeAfterTest(shouldContinue) {\n\t\tif (shouldContinue) {\n\t\t\tdo {\n\t\t\t\tresult = body();\n\t\t\t\tif (result && result.then) {\n\t\t\t\t\tif (_isSettledPact(result)) {\n\t\t\t\t\t\tresult = result.v;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tshouldContinue = test();\n\t\t\t\tif (_isSettledPact(shouldContinue)) {\n\t\t\t\t\tshouldContinue = shouldContinue.v;\n\t\t\t\t}\n\t\t\t\tif (!shouldContinue) {\n\t\t\t\t\t_settle(pact, 1, result);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t} while (!shouldContinue.then);\n\t\t\tshouldContinue.then(_resumeAfterTest).then(void 0, reject);\n\t\t} else {\n\t\t\t_settle(pact, 1, result);\n\t\t}\n\t}\n}\n\n// Asynchronously implement a switch statement\nexport function _switch(discriminant, cases) {\n\tvar dispatchIndex = -1;\n\tvar awaitBody;\n\touter: {\n\t\tfor (var i = 0; i < cases.length; i++) {\n\t\t\tvar test = cases[i][0];\n\t\t\tif (test) {\n\t\t\t\tvar testValue = test();\n\t\t\t\tif (testValue && testValue.then) {\n\t\t\t\t\tbreak outer;\n\t\t\t\t}\n\t\t\t\tif (testValue === discriminant) {\n\t\t\t\t\tdispatchIndex = i;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// Found the default case, set it as the pending dispatch case\n\t\t\t\tdispatchIndex = i;\n\t\t\t}\n\t\t}\n\t\tif (dispatchIndex !== -1) {\n\t\t\tdo {\n\t\t\t\tvar body = cases[dispatchIndex][1];\n\t\t\t\twhile (!body) {\n\t\t\t\t\tdispatchIndex++;\n\t\t\t\t\tbody = cases[dispatchIndex][1];\n\t\t\t\t}\n\t\t\t\tvar result = body();\n\t\t\t\tif (result && result.then) {\n\t\t\t\t\tawaitBody = true;\n\t\t\t\t\tbreak outer;\n\t\t\t\t}\n\t\t\t\tvar fallthroughCheck = cases[dispatchIndex][2];\n\t\t\t\tdispatchIndex++;\n\t\t\t} while (fallthroughCheck && !fallthroughCheck());\n\t\t\treturn result;\n\t\t}\n\t}\n\tconst pact = new _Pact();\n\tconst reject = _settle.bind(null, pact, 2);\n\t(awaitBody ? result.then(_resumeAfterBody) : testValue.then(_resumeAfterTest)).then(void 0, reject);\n\treturn pact;\n\tfunction _resumeAfterTest(value) {\n\t\tfor (;;) {\n\t\t\tif (value === discriminant) {\n\t\t\t\tdispatchIndex = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (++i === cases.length) {\n\t\t\t\tif (dispatchIndex !== -1) {\n\t\t\t\t\tbreak;\n\t\t\t\t} else {\n\t\t\t\t\t_settle(pact, 1, result);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t\ttest = cases[i][0];\n\t\t\tif (test) {\n\t\t\t\tvalue = test();\n\t\t\t\tif (value && value.then) {\n\t\t\t\t\tvalue.then(_resumeAfterTest).then(void 0, reject);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tdispatchIndex = i;\n\t\t\t}\n\t\t}\n\t\tdo {\n\t\t\tvar body = cases[dispatchIndex][1];\n\t\t\twhile (!body) {\n\t\t\t\tdispatchIndex++;\n\t\t\t\tbody = cases[dispatchIndex][1];\n\t\t\t}\n\t\t\tvar result = body();\n\t\t\tif (result && result.then) {\n\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tvar fallthroughCheck = cases[dispatchIndex][2];\n\t\t\tdispatchIndex++;\n\t\t} while (fallthroughCheck && !fallthroughCheck());\n\t\t_settle(pact, 1, result);\n\t}\n\tfunction _resumeAfterBody(result) {\n\t\tfor (;;) {\n\t\t\tvar fallthroughCheck = cases[dispatchIndex][2];\n\t\t\tif (!fallthroughCheck || fallthroughCheck()) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tdispatchIndex++;\n\t\t\tvar body = cases[dispatchIndex][1];\n\t\t\twhile (!body) {\n\t\t\t\tdispatchIndex++;\n\t\t\t\tbody = cases[dispatchIndex][1];\n\t\t\t}\n\t\t\tresult = body();\n\t\t\tif (result && result.then) {\n\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\t_settle(pact, 1, result);\n\t}\n}\n\n// Asynchronously call a function and pass the result to explicitly passed continuations\nexport function _call(body, then, direct) {\n\tif (direct) {\n\t\treturn then ? then(body()) : body();\n\t}\n\ttry {\n\t\tvar result = Promise.resolve(body());\n\t\treturn then ? result.then(then) : result;\n\t} catch (e) {\n\t\treturn Promise.reject(e);\n\t}\n}\n\n// Asynchronously call a function and swallow the result\nexport function _callIgnored(body, direct) {\n\treturn _call(body, _empty, direct);\n}\n\n// Asynchronously call a function and pass the result to explicitly passed continuations\nexport function _invoke(body, then) {\n\tvar result = body();\n\tif (result && result.then) {\n\t\treturn result.then(then);\n\t}\n\treturn then(result);\n}\n\n// Asynchronously call a function and swallow the result\nexport function _invokeIgnored(body) {\n\tvar result = body();\n\tif (result && result.then) {\n\t\treturn result.then(_empty);\n\t}\n}\n\n// Asynchronously call a function and send errors to recovery continuation\nexport function _catch(body, recover) {\n\ttry {\n\t\tvar result = body();\n\t} catch(e) {\n\t\treturn recover(e);\n\t}\n\tif (result && result.then) {\n\t\treturn result.then(void 0, recover);\n\t}\n\treturn result;\n}\n\n// Asynchronously await a promise and pass the result to a finally continuation\nexport function _finallyRethrows(body, finalizer) {\n\ttry {\n\t\tvar result = body();\n\t} catch (e) {\n\t\treturn finalizer(true, e);\n\t}\n\tif (result && result.then) {\n\t\treturn result.then(finalizer.bind(null, false), finalizer.bind(null, true));\n\t}\n\treturn finalizer(false, result);\n}\n\n// Asynchronously await a promise and invoke a finally continuation that always overrides the result\nexport function _finally(body, finalizer) {\n\ttry {\n\t\tvar result = body();\n\t} catch (e) {\n\t\treturn finalizer();\n\t}\n\tif (result && result.then) {\n\t\treturn result.then(finalizer, finalizer);\n\t}\n\treturn finalizer();\n}\n\n// Rethrow or return a value from a finally continuation\nexport function _rethrow(thrown, value) {\n\tif (thrown)\n\t\tthrow value;\n\treturn value;\n}\n\n// Empty function to implement break and other control flow that ignores asynchronous results\nexport function _empty() {\n}\n\n// Sentinel value for early returns in generators \nexport const _earlyReturn = /*#__PURE__*/ {};\n\n// Asynchronously call a function and send errors to recovery continuation, skipping early returns\nexport function _catchInGenerator(body, recover) {\n\treturn _catch(body, function(e) {\n\t\tif (e === _earlyReturn) {\n\t\t\tthrow e;\n\t\t}\n\t\treturn recover(e);\n\t});\n}\n\n// Asynchronous generator class; accepts the entrypoint of the generator, to which it passes itself when the generator should start\nexport const _AsyncGenerator = /*#__PURE__*/(function() {\n\tfunction _AsyncGenerator(entry) {\n\t\tthis._entry = entry;\n\t\tthis._pact = null;\n\t\tthis._resolve = null;\n\t\tthis._return = null;\n\t\tthis._promise = null;\n\t}\n\n\tfunction _wrapReturnedValue(value) {\n\t\treturn { value: value, done: true };\n\t}\n\tfunction _wrapYieldedValue(value) {\n\t\treturn { value: value, done: false };\n\t}\n\n\t_AsyncGenerator.prototype._yield = function(value) {\n\t\t// Yield the value to the pending next call\n\t\tthis._resolve(value && value.then ? value.then(_wrapYieldedValue) : _wrapYieldedValue(value));\n\t\t// Return a pact for an upcoming next/return/throw call\n\t\treturn this._pact = new _Pact();\n\t};\n\t_AsyncGenerator.prototype.next = function(value) {\n\t\t// Advance the generator, starting it if it has yet to be started\n\t\tconst _this = this;\n\t\treturn _this._promise = new Promise(function (resolve) {\n\t\t\tconst _pact = _this._pact;\n\t\t\tif (_pact === null) {\n\t\t\t\tconst _entry = _this._entry;\n\t\t\t\tif (_entry === null) {\n\t\t\t\t\t// Generator is started, but not awaiting a yield expression\n\t\t\t\t\t// Abandon the next call!\n\t\t\t\t\treturn resolve(_this._promise);\n\t\t\t\t}\n\t\t\t\t// Start the generator\n\t\t\t\t_this._entry = null;\n\t\t\t\t_this._resolve = resolve;\n\t\t\t\tfunction returnValue(value) {\n\t\t\t\t\t_this._resolve(value && value.then ? value.then(_wrapReturnedValue) : _wrapReturnedValue(value));\n\t\t\t\t\t_this._pact = null;\n\t\t\t\t\t_this._resolve = null;\n\t\t\t\t}\n\t\t\t\tvar result = _entry(_this);\n\t\t\t\tif (result && result.then) {\n\t\t\t\t\tresult.then(returnValue, function(error) {\n\t\t\t\t\t\tif (error === _earlyReturn) {\n\t\t\t\t\t\t\treturnValue(_this._return);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tconst pact = new _Pact();\n\t\t\t\t\t\t\t_this._resolve(pact);\n\t\t\t\t\t\t\t_this._pact = null;\n\t\t\t\t\t\t\t_this._resolve = null;\n\t\t\t\t\t\t\t_resolve(pact, 2, error);\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t} else {\n\t\t\t\t\treturnValue(result);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// Generator is started and a yield expression is pending, settle it\n\t\t\t\t_this._pact = null;\n\t\t\t\t_this._resolve = resolve;\n\t\t\t\t_settle(_pact, 1, value);\n\t\t\t}\n\t\t});\n\t};\n\t_AsyncGenerator.prototype.return = function(value) {\n\t\t// Early return from the generator if started, otherwise abandons the generator\n\t\tconst _this = this;\n\t\treturn _this._promise = new Promise(function (resolve) {\n\t\t\tconst _pact = _this._pact;\n\t\t\tif (_pact === null) {\n\t\t\t\tif (_this._entry === null) {\n\t\t\t\t\t// Generator is started, but not awaiting a yield expression\n\t\t\t\t\t// Abandon the return call!\n\t\t\t\t\treturn resolve(_this._promise);\n\t\t\t\t}\n\t\t\t\t// Generator is not started, abandon it and return the specified value\n\t\t\t\t_this._entry = null;\n\t\t\t\treturn resolve(value && value.then ? value.then(_wrapReturnedValue) : _wrapReturnedValue(value));\n\t\t\t}\n\t\t\t// Settle the yield expression with a rejected \"early return\" value\n\t\t\t_this._return = value;\n\t\t\t_this._resolve = resolve;\n\t\t\t_this._pact = null;\n\t\t\t_settle(_pact, 2, _earlyReturn);\n\t\t});\n\t};\n\t_AsyncGenerator.prototype.throw = function(error) {\n\t\t// Inject an exception into the pending yield expression\n\t\tconst _this = this;\n\t\treturn _this._promise = new Promise(function (resolve, reject) {\n\t\t\tconst _pact = _this._pact;\n\t\t\tif (_pact === null) {\n\t\t\t\tif (_this._entry === null) {\n\t\t\t\t\t// Generator is started, but not awaiting a yield expression\n\t\t\t\t\t// Abandon the throw call!\n\t\t\t\t\treturn resolve(_this._promise);\n\t\t\t\t}\n\t\t\t\t// Generator is not started, abandon it and return a rejected Promise containing the error\n\t\t\t\t_this._entry = null;\n\t\t\t\treturn reject(error);\n\t\t\t}\n\t\t\t// Settle the yield expression with the value as a rejection\n\t\t\t_this._resolve = resolve;\n\t\t\t_this._pact = null;\n\t\t\t_settle(_pact, 2, error);\n\t\t});\n\t};\n\n\t_AsyncGenerator.prototype[_asyncIteratorSymbol] = function() {\n\t\treturn this;\n\t};\n\t\n\treturn _AsyncGenerator;\n})();\n","const BUILTINS = {\r\n    ver: () => process.env.REACT_APP_COMMIT_HASH || require('../package.json').version,\r\n    help: () => `Command Interpreter version ${BUILTINS['ver']()}\\n© Iain MacDonald\\n\\nBuiltin commands:\\n${BUILTINS['commands']().join(\"\\n\")}`,\r\n    commands: getCommands,\r\n    variables () { return this.context.variables }, // Not fat arrow, so `this` can be used\r\n    get: getVariable,\r\n    set: setVariable,\r\n    date: () => new Date(),\r\n    type: v => v instanceof Date ? \"date\" : (Array.isArray(v) ? \"list\" : (v === null ? \"\": typeof v)),\r\n    sleep: n => new Promise(r => setTimeout(r, n * 1000)),\r\n    echo: (...a) => a.flat().filter(isNotNull).map(toString).join(\" \"),\r\n    cast: (v,t) => {\r\n        if (t === \"number\") return +v;\r\n        if (t === \"string\") return toString(v);\r\n        if (t === \"list\" && typeof v === \"string\") return v.split(\"\\n\");\r\n        return v;\r\n    },\r\n    length: v => (Array.isArray(v) ? v : (typeof v === \"string\" ? v.split(\"\\n\") : [v])).length,\r\n    json: (...a) => a.length === 0 ? null : (a.length === 1 ? JSON.stringify(a[0]) : JSON.stringify(a)),\r\n    range: n => Array(n).fill(0).map((n,i) => i),\r\n    grep: (a, r) => {\r\n        try{\r\n            const re = new RegExp(r);\r\n            return a.filter(v => re.test(v));\r\n        } catch (e) {\r\n            return a.filter(v => v.includes(r));\r\n        }\r\n    },\r\n    index: (a, i) => a[i],\r\n    async tee (value, ...options) {\r\n        const variable = options.find(o => !o.startsWith(\"-\")) || \"output\";\r\n        const append = options.some(o => o === \"-a\");\r\n        if (append) {\r\n            const oldVal = await getVariable.call(this, variable) || [];\r\n            const newVal = Array.isArray(oldVal) ? oldVal : [ oldVal ];\r\n            newVal.push(value);\r\n            setVariable.call(this, variable, newVal);\r\n        } else {\r\n            setVariable.call(this, variable, value);\r\n        }\r\n        return value;\r\n    },\r\n    eval (...input) {\r\n        const tokens = tokenise(input.join(\" \"));\r\n        if (tokens.length === 0) return;\r\n        const statements = parse(tokens);\r\n        return run.call(this, statements[0]);\r\n    }\r\n};\r\n\r\nif (typeof alert !== \"undefined\") {\r\n    BUILTINS['alert'] = (...a) => alert(BUILTINS['echo'](...a));\r\n}\r\n\r\nconst CONTROL = [\"foreach\",\"done\"];\r\nconst OPERATORS = [\"+\",\"-\",\"*\",\"/\"];\r\n\r\nexport default class Shell {\r\n    constructor (context = {}) {\r\n        this.context = context;\r\n    }\r\n\r\n    /**\r\n     *\r\n     * @param {string} input\r\n     */\r\n    async execute (input, output=this.output, error=this.error) {\r\n        if (typeof this.context.variables === \"undefined\") {\r\n            this.context.variables = {};\r\n        }\r\n\r\n        this.output = output;\r\n        this.error = error;\r\n\r\n        try {\r\n            const tokens = tokenise(input);\r\n\r\n            if (tokens.length === 0) return;\r\n\r\n            const statements = parse(tokens);\r\n\r\n            await this.executeStatements(statements, output, error);\r\n        } catch (e) {\r\n            error(e.message);\r\n        }\r\n    }\r\n\r\n    /**\r\n     *\r\n     * @param {StatementNode[]} statements\r\n     * @param {(output: string) => void} output\r\n     * @param {(error: string) => void} error\r\n     */\r\n    async executeStatements(statements, output, error) {\r\n        const { variables } = this.context;\r\n\r\n        for (let i = 0; i < statements.length; i++) {\r\n\r\n            const statement = statements[i];\r\n            if (statement.control === \"foreach\") {\r\n                const items = BUILTINS['cast'](await run.call(this, statement.args[0]), \"list\");\r\n                const loopVar = statement.args[1] ? await run.call(this, statement.args[1]) : \"item\";\r\n                this.context.forLoop = {\r\n                    originalItem: variables[loopVar],\r\n                    start: i,\r\n                    items,\r\n                    iteration: 0,\r\n                    loopVar,\r\n                };\r\n\r\n                // TODO: this doesn't support nested loops\r\n                const doneIndex = statements.slice(i + 1).findIndex(s => s.control === \"done\");\r\n\r\n                if (doneIndex === -1) {\r\n                    throw Error(\"Unterminated foreach loop\");\r\n                }\r\n\r\n                if (items.length === 0) {\r\n                    i = doneIndex;\r\n                    continue;\r\n                }\r\n\r\n                variables[loopVar] = items[0];\r\n            }\r\n            else if (statement.control === \"done\") {\r\n                const { forLoop, variables } = this.context;\r\n\r\n                if (forLoop) {\r\n                    forLoop.iteration++;\r\n                    if (forLoop.iteration < forLoop.items.length) {\r\n                        i = forLoop.start;\r\n                        variables[forLoop.loopVar] = forLoop.items[forLoop.iteration];\r\n                    }\r\n                    else {\r\n                        if (typeof forLoop.originalItem === \"undefined\") {\r\n                            delete variables[forLoop.loopVar];\r\n                        }\r\n                        else {\r\n                            variables[forLoop.loopVar] = forLoop.originalItem;\r\n                        }\r\n                        this.context.forLoop = null;\r\n                    }\r\n                }\r\n                else {\r\n                    throw Error(`Unexpected control word: ${statement.control}`);\r\n                }\r\n            }\r\n            else {\r\n                await this.executeStatementOperator(statement, output, error);\r\n            }\r\n        }\r\n    }\r\n\r\n    async executeStatementOperator (statement, output, error) {\r\n        let promise;\r\n        const self = this;\r\n        const originalContext = this.context;\r\n        // capture context\r\n        // bug fix from foreach loop e.g.\r\n        //      range 10 | foreach; sleep $item && echo $item &; done\r\n        const context = { ...originalContext, variables: { ...originalContext.variables } };\r\n\r\n        if (statement.operator === \"&&\") {\r\n            promise = this.executeStatementOperator(statement.left, output, error).then(() => {\r\n                self.context = context;\r\n                return self.executeStatementOperator(statement.right, output, error).then(() => {\r\n                    self.context = originalContext;\r\n                });\r\n            });\r\n        } else {\r\n            promise = this.executeStatement(statement, output, error);\r\n        }\r\n\r\n        if (statement.background) {\r\n            promise.catch(e => { throw e; });\r\n        } else {\r\n            await promise;\r\n        }\r\n    }\r\n\r\n    async executeStatement(statement, output, error) {\r\n        const { variables } = this.context;\r\n\r\n        try {\r\n            const result = await run.call(this, statement);\r\n            output(toString(result));\r\n            variables[0] = result;\r\n        }\r\n        catch (e) {\r\n            error(e.message);\r\n        }\r\n    }\r\n}\r\n\r\n/**\r\n *\r\n * @param {any} value\r\n * @returns {string}\r\n */\r\nfunction toString (value) {\r\n    if (typeof value === \"undefined\" || value === null) return \"\";\r\n    if (value instanceof Date) return value.toISOString();\r\n    if (Array.isArray(value)) return value.map(toString).join(\"\\n\");\r\n    if (typeof value === \"object\") return Object.entries(value).map(([n,v]) => `${n} = ${toString(v)}`).join(\"\\n\");\r\n    return String(value);\r\n}\r\n\r\nasync function run (statement) {\r\n    if (typeof statement !== \"object\") return statement;\r\n\r\n    // e.g. $$variable\r\n    if (typeof statement.variable === \"object\") return getVariable.call(this, await run.call(this, statement.variable));\r\n\r\n    if (typeof statement.variable === \"string\") return getVariable.call(this, statement.variable);\r\n\r\n    if (typeof statement.operator === \"string\") {\r\n        if (statement.operator === \"=\")\r\n            return setVariable.call(this, statement.name, await run.call(this, statement.value));\r\n\r\n        const left = await run.call(this, statement.left);\r\n        const right = await run.call(this, statement.right);\r\n\r\n        // eslint-disable-next-line\r\n        switch (statement.operator) {\r\n            case \"+\": return left + right;\r\n            case \"-\": return left - right;\r\n            case \"*\": return left * right;\r\n            case \"/\": return left / right;\r\n        }\r\n\r\n        throw Error(`Unrecognised operator: ${statement.operator}`);\r\n    }\r\n\r\n    let { command, args } = statement;\r\n\r\n    const evaldArgs = await Promise.all(args.map(arg => {\r\n        if (typeof arg === \"object\") {\r\n            return run.call(this, arg);\r\n        }\r\n\r\n        return arg;\r\n    }));\r\n\r\n    if (command in BUILTINS) {\r\n        return BUILTINS[command].call(this, ...evaldArgs);\r\n    }\r\n\r\n    return executeCommand.call(this, command, evaldArgs);\r\n};\r\n\r\nasync function getVariable (name) {\r\n    let { context } = this;\r\n\r\n    // Descend through contexts\r\n    // deeper and deeper into each parent until we find variable\r\n    while (context) {\r\n        const { executables = {}, variables = {} } = context;\r\n\r\n        if ('get' in executables) {\r\n            try {\r\n                const result = await executables.get(name);\r\n                return result;\r\n            } catch (e) {}\r\n        }\r\n\r\n        if (name in variables) return variables[name];\r\n\r\n        context = context.parent;\r\n    }\r\n\r\n    // special cases\r\n    if (name === \"commands\") return BUILTINS['commands'].call(this);\r\n    if (name === \"variables\") return [...Object.keys(this.context.variables), \"commands\", \"variables\"];\r\n}\r\n\r\nasync function setVariable (name, value) {\r\n    let { context } = this;\r\n\r\n    // Descend through contexts\r\n    // deeper and deeper into each parent until we find variable\r\n    while (context) {\r\n        const { executables = {}, variables = {} } = context;\r\n\r\n        if ('set' in executables) {\r\n            try {\r\n                const result = await executables.set(name, value);\r\n                return result;\r\n            } catch (e) {}\r\n        }\r\n\r\n        if (name in variables) {\r\n            try {\r\n                variables[name] = value;\r\n                return value;\r\n            } catch (e) {\r\n                throw Error(`${name} is readonly`);\r\n            }\r\n        }\r\n\r\n        context = context.parent;\r\n    }\r\n\r\n    // If we're here we got to the deepest context without finding the variable\r\n    // we're just going to set it on the highest context\r\n    try {\r\n        this.context.variables[name] = value;\r\n        return value;\r\n    } catch (e) {\r\n        throw Error(`${name} is readonly`);\r\n    }\r\n}\r\n\r\nasync function executeCommand (command, evaldArgs) {\r\n    let { context } = this;\r\n\r\n    while (context) {\r\n        const { executables = {} } = context;\r\n\r\n        if (command in executables) {\r\n            return executables[command].call(this, ...evaldArgs);\r\n        }\r\n\r\n        context = context.parent;\r\n    }\r\n\r\n    throw Error(`Command '${command}' not found`);\r\n}\r\n\r\nfunction getCommands () {\r\n    const cmds = new Set(Object.keys(BUILTINS));\r\n\r\n    let { context } = this;\r\n\r\n    // Descend through contexts\r\n    while (context) {\r\n        const { executables = {} } = context;\r\n\r\n        Object.keys(executables).forEach(cmds.add.bind(cmds));\r\n\r\n        context = context.parent;\r\n    }\r\n\r\n    return Array.from(cmds).sort();\r\n}\r\n\r\n/**\r\n *\r\n * @param {string} text\r\n * @returns {string[]}\r\n */\r\nfunction tokenise (text) {\r\n    const tokens = [];\r\n    let i = 0;\r\n\r\n    const matchers = [\r\n        {\r\n            name: \"whitespace\",\r\n            regex: /^\\s+/,\r\n            value: () => \"\",\r\n        },\r\n        {\r\n            name: \"string\",\r\n            regex: /^\"([^\"]*)\"/,\r\n            value: v => v.replace(/\\\\n/g, \"\\n\").replace(/\\\\t/g, \"\\t\"),\r\n        },\r\n        {\r\n            name: \"string_verbatim\",\r\n            regex: /^'[^']*'/,\r\n            value: v => v.replace(/\\\\n/g, \"\\n\").replace(/\\\\t/g, \"\\t\"),\r\n        },\r\n        {\r\n            name: \"num\",\r\n            regex: /^-?\\d+(?:\\.\\d+)?/,\r\n            value: v => +v,\r\n        },\r\n        {\r\n            name: \"variable\",\r\n            regex: /^\\$+\\w+/,\r\n        },\r\n        {\r\n            name: \"boolean\",\r\n            regex: /^(true|false)/,\r\n            value: v => v === \"true\",\r\n        },\r\n        {\r\n            name: \"punctuation\",\r\n            regex: /^(;|\\${|}|&&|[|=+*/&])/,\r\n        },\r\n        {\r\n            name: \"keyword\",\r\n            regex: /^(foreach|done)/,\r\n        },\r\n        {\r\n            name: \"name\",\r\n            regex: /^[\\w-]+/,\r\n        },\r\n    ]\r\n\r\n    while (i < text.length) {\r\n        const tail = text.substr(i);\r\n\r\n        let done = false;\r\n\r\n        for (const m of matchers) {\r\n            const match = m.regex.exec(tail);\r\n            if (match) {\r\n                let val = match[1] || match[0];\r\n\r\n                if (m.value instanceof Function) {\r\n                    val = m.value(val);\r\n                } else if (typeof m.value !== \"undefined\") {\r\n                    val = m.value;\r\n                }\r\n\r\n                if (typeof val !== \"undefined\" && val !== null && val !== \"\")\r\n                    tokens.push(val);\r\n\r\n                i += match[0].length;\r\n                done = true;\r\n                break;\r\n            }\r\n        }\r\n\r\n        if (!done) {\r\n            // Prompt   '> '\r\n            throw Error(`  ${\" \".repeat(i)}^\\nUnexpected input at ${i}: ${text.substr(i, 10)}`);\r\n        }\r\n    }\r\n\r\n    return tokens;\r\n}\r\n\r\n/**\r\n * @typedef StatementNode\r\n * @prop {string} [control]\r\n * @prop {string} [command]\r\n * @prop {StatementNode[]} [args]\r\n * @prop {string} [operator]\r\n * @prop {string|StatementNode} [name]\r\n * @prop {StatementNode} [variable]\r\n * @prop {string|StatementNode} [value]\r\n * @prop {string|StatementNode} [left]\r\n * @prop {string|StatementNode} [right]\r\n * @prop {boolean} [background]\r\n */\r\n\r\n/**\r\n *\r\n * @param {string[]} tokens\r\n * @returns {StatementNode[]}\r\n */\r\nfunction parse (tokens) {\r\n    const statements = splitTokens(tokens, \";\").map(parseStatementOperators);\r\n\r\n    return statements;\r\n}\r\n\r\n/**\r\n *\r\n * @param {string[]} tokens\r\n * @returns {StatementNode}\r\n */\r\nfunction parseStatementOperators (tokens) {\r\n    let background = false;\r\n\r\n    if (tokens[tokens.length-1] === \"&\") {\r\n        background = true;\r\n        tokens.length--;\r\n    }\r\n\r\n    const statements = splitTokens(tokens, \"&&\").map(parseStatement);\r\n\r\n    const statement = joinStatementOperators(statements);\r\n\r\n    statement.background = background;\r\n\r\n    return statement;\r\n}\r\n\r\n/**\r\n *\r\n * @param {*} items\r\n * @returns {StatementNode}\r\n */\r\nfunction makeNode (items) {\r\n    if (items.length === 3 && typeof items[0] === \"string\" && items[1] === \"=\") {\r\n        return {\r\n            operator: \"=\",\r\n            name: items[0],\r\n            value: items[2],\r\n        };\r\n    }\r\n\r\n    if (items.length === 3 && OPERATORS.includes(items[1])) {\r\n        return {\r\n            operator: items[1],\r\n            left: items[0],\r\n            right: items[2],\r\n        };\r\n    }\r\n\r\n    if (typeof items[0].variable !== \"undefined\") {\r\n        if (items.length > 1)\r\n            throw Error(\"Variable evaluation must be only node in statement\");\r\n        return items[0];\r\n    }\r\n\r\n    if (typeof items[0] === \"number\")\r\n        return items[0];\r\n\r\n    if (CONTROL.includes(items[0])) {\r\n        const [control, ...args] = items;\r\n        return { control, args };\r\n    }\r\n\r\n    const [command, ...args] = items;\r\n    return { command, args };\r\n}\r\n\r\n/**\r\n *\r\n * @param {string[]} tokens\r\n * @returns {StatementNode}\r\n */\r\nfunction parseStatement (tokens) {\r\n    const pipes = [];\r\n\r\n    let items = [];\r\n\r\n    for (let i = 0; i < tokens.length; i++) {\r\n        const t = tokens[i];\r\n        if (t === \"|\") {\r\n            pipes.push(makeNode(items));\r\n            items = [];\r\n        }\r\n        else if (t === \"${\") {\r\n            const tail = tokens.slice(i+1);\r\n            const end = tail.indexOf(\"}\");\r\n            if (end === -1) throw Error(\"Unterminated sub-expression\");\r\n            items.push(parseStatement(tail.slice(0, end)));\r\n            i += end + 1;\r\n        }\r\n        else if (typeof t === \"number\") {\r\n            items.push(t);\r\n        }\r\n        else if (typeof t === \"string\" && t[0] === \"$\") {\r\n            let name = t.substr(1);\r\n            /** @type {{ variable: string|{ variable: string }}} */\r\n            let item = { variable: name };\r\n\r\n            // Only two levels deep for $$variables\r\n            if (name[0] === \"$\") {\r\n                item = {\r\n                    variable: {\r\n                        variable: name.substr(1),\r\n                    },\r\n                };\r\n            }\r\n\r\n            items.push(item);\r\n        }\r\n        else if (typeof t === \"string\" && t[0] === \"'\") {\r\n            const str = t.substr(1, t.length - 2);\r\n\r\n            items.push(str);\r\n        }\r\n        else items.push(t);\r\n    }\r\n\r\n    if (items.length === 0) throw Error(\"Empty pipe segment\");\r\n\r\n    pipes.push(makeNode(items));\r\n\r\n    const statement = joinPipes(pipes);\r\n\r\n    return statement;\r\n}\r\n\r\n/**\r\n *\r\n * @param {StatementNode[]} pipes\r\n * @returns {StatementNode}\r\n */\r\nfunction joinPipes(pipes) {\r\n    return pipes.reduce((prev, curr) => {\r\n        if (prev === null)\r\n            return curr;\r\n\r\n        // replace pipe-into-variable scenario with assignment\r\n        if (typeof curr.variable !== \"undefined\") {\r\n            return {\r\n                operator: \"=\",\r\n                name: curr.variable,\r\n                value: prev,\r\n            };\r\n        }\r\n\r\n        if (!curr.args) {\r\n            throw Error(`Unable to pipe to ${typeof curr}`);\r\n        }\r\n\r\n        curr.args.unshift(prev);\r\n\r\n        return curr;\r\n    }, null);\r\n}\r\n\r\n/**\r\n *\r\n * @param {StatementNode[]} statements\r\n * @returns {StatementNode}\r\n */\r\nfunction joinStatementOperators(statements) {\r\n    return statements.reduce((prev, curr) => {\r\n        if (prev === null)\r\n            return curr;\r\n\r\n        return {\r\n            operator: \"&&\",\r\n            left: prev,\r\n            right: curr,\r\n        };\r\n    }, null);\r\n}\r\n\r\n/**\r\n * @param {string[]} tokens\r\n * @param {string} separator\r\n * @returns {string[][]}\r\n */\r\nfunction splitTokens (tokens, separator) {\r\n    const out = [];\r\n    let current = [];\r\n    for (let i = 0; i < tokens.length; i++) {\r\n        if (tokens[i] === separator && current.length) {\r\n            out.push(current);\r\n            current = [];\r\n        } else current.push(tokens[i]);\r\n    }\r\n    if (current.length) out.push(current);\r\n    return out;\r\n}\r\n\r\n\r\nfunction isNull (v) {\r\n    return typeof v === \"undefined\" || v === null || v === \"\";\r\n}\r\n\r\nfunction isNotNull (v) {\r\n    return !isNull(v);\r\n}","import React from 'react';\r\nimport Shell from './shell';\r\n\r\nimport classes from './console.css';\r\n\r\n/**\r\n * @param {object} props\r\n * @param {Shell} [props.shell]\r\n * @param {object} [props.context]\r\n * @param {React.CSSProperties} [props.style]\r\n * @param {() => void} [props.onClose]\r\n */\r\nexport default function ConsoleDisplay ({ shell = null, context = {}, style = {}, onClose = null }) {\r\n    const [ hist, setHist ] = React.useState([]);\r\n    const [ input, setInput ] = React.useState(\"\");\r\n    const [ scrollback, setScrollback ] = React.useState(0);\r\n    const [ executing, setExecuting ] = React.useState(false);\r\n    /** @type {React.MutableRefObject<HTMLInputElement>} */\r\n    const inputRef = React.useRef();\r\n    const shellRef = React.useRef(shell || new Shell(context));\r\n    /** @type {React.MutableRefObject<HTMLDivElement>} */\r\n    const outerRef = React.useRef();\r\n    const [ textColor, setTextColor ] = React.useState(style.color);\r\n    const [ backgroundColor, setBackgroundColor ] = React.useState(style.backgroundColor);\r\n\r\n    React.useEffect(() => {\r\n        context.parent = {\r\n            variables: {\r\n                textColor,\r\n                backgroundColor\r\n            },\r\n            executables: {\r\n                set (name, value) {\r\n                    if (name === \"textColor\") return setTextColor(value);\r\n                    if (name === \"backgroundColor\") return setBackgroundColor(value);\r\n                    throw Error(\"Unhandled\");\r\n                },\r\n                exit: onClose || (() => {}),\r\n                clear: () => setHist([]),\r\n            },\r\n        };\r\n    }, [ context, textColor, setTextColor, backgroundColor, setBackgroundColor, onClose, setHist ]);\r\n\r\n    React.useEffect(() => {\r\n        inputRef.current && inputRef.current.focus();\r\n        outerRef.current && (outerRef.current.scrollTop = outerRef.current.scrollHeight);\r\n    }, [hist,executing]);\r\n\r\n    const handleSubmit = React.useCallback(e => {\r\n        function pushHist (newItem) {\r\n            setHist(hist => [ ...hist, newItem ]);\r\n        }\r\n\r\n        async function handleSubmit (e) {\r\n            e.preventDefault();\r\n\r\n            setInput(\"\");\r\n            setScrollback(0);\r\n            pushHist({ value: input, type: \"input\" });\r\n\r\n            if (shellRef.current) {\r\n                setExecuting(true);\r\n\r\n                await shellRef.current.execute(\r\n                    input,\r\n                    output => {\r\n                        pushHist({ value: output, type: \"output\" });\r\n                    },\r\n                    error => {\r\n                        pushHist({ value: error, type: \"error\" });\r\n                    }\r\n                );\r\n\r\n                setExecuting(false);\r\n            } else {\r\n                pushHist({ value: \"No interpreter specified\", type: \"error\" });\r\n            }\r\n        }\r\n\r\n        handleSubmit(e);\r\n    }, [input, setInput, setScrollback, setHist, setExecuting]);\r\n\r\n    /**\r\n     *\r\n     * @param {React.KeyboardEvent<HTMLInputElement>} e\r\n     */\r\n    function handleKeyUp (e) {\r\n        const inputHist = hist.filter(h => h.type === \"input\" && h.value);\r\n        let nextScrollback = NaN;\r\n\r\n        if (e.key === \"ArrowUp\") {\r\n            nextScrollback = Math.min(scrollback + 1, inputHist.length);\r\n        }\r\n        else if (e.key === \"ArrowDown\") {\r\n            nextScrollback = Math.max(scrollback - 1, 0);\r\n        }\r\n\r\n        if (!isNaN(nextScrollback)) {\r\n            setScrollback(nextScrollback);\r\n\r\n            if (nextScrollback === 0 && scrollback !== 0) {\r\n                setInput(\"\");\r\n            } else if (nextScrollback !== 0) {\r\n                setInput(inputHist[inputHist.length - nextScrollback].value);\r\n            }\r\n        }\r\n    }\r\n\r\n    const divStyle = { height: \"100%\", ...style, color: textColor, background: backgroundColor };\r\n\r\n    return (\r\n        <div className={classes.ConsoleDisplay} ref={outerRef} onClick={() => getSelection().type !== \"Range\" && inputRef.current.focus()} style={divStyle}>\r\n            <ul>{ hist.map((l,i) => <li key={i} className={classes[`ConsoleDisplay-hist-${l.type}`]}>{l.value}</li>) }</ul>\r\n            <form onSubmit={handleSubmit}>\r\n                { !executing && '> ' }\r\n                <input\r\n                    value={input}\r\n                    ref={inputRef}\r\n                    disabled={executing}\r\n                    onChange={e => setInput(e.target.value)}\r\n                    onKeyUp={handleKeyUp}\r\n                    // prevent cursor from jumping to beginning of line\r\n                    onKeyDown={e => e.key === \"ArrowUp\" && e.preventDefault()}\r\n                    autoFocus\r\n                />\r\n            </form>\r\n        </div>\r\n    );\r\n}","import React from 'react';\nimport './App.css';\nimport { Console } from 'app-console';\n\nimport \"app-console/dist/index.css\";\n\nconst demoScript = `\necho Welcome to the demo \"script.\";\nsleep 1;\necho Sit back and watch some sample commands;\nsleep 1;\necho executed before your \"eyes!\";\nsleep 1;\necho \">\" date;\ndate;\nsleep 1;\necho \">\" sleep 3;\nsleep 3;\necho \">\" date;\ntee \\${date} d;\nsleep 1;\necho \">\" echo '$0';\necho $d;\nsleep 1;\necho \">\" 5 + 2;\n5 + 2;\nsleep 1;\necho \">\" a = '\\${6 * 2}';\na = \\${6 * 2};\nsleep 1;\necho \">\" echo Answer is '$a';\necho Answer is $a;\nsleep 1;\necho \">\" range 3;\nrange 3;\nsleep 1;\necho \">\" '$0 | json';\nrange 3 | json;\nsleep 1;\necho '> range 50 | grep 7' ;\nrange 50 | grep 7;\nsleep 1;\necho '> foreach \\${range 10}; sleep 1; $item; done;';\nforeach \\${range 10}; sleep 1; $item; done;\necho ' ';\necho 'Thanks!';\n`;\n\nconst executables = {\n  demo () {\n    return this.execute(demoScript);\n  },\n};\n\nfunction App() {\n  return (\n    <div className=\"App\">\n      <p>Type demo or help to get started.</p>\n      <Console context={{ executables }} />\n    </div>\n  );\n}\n\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' },\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready\n      .then(registration => {\n        registration.unregister();\n      })\n      .catch(error => {\n        console.error(error.message);\n      });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}