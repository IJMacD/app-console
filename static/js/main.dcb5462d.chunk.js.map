{"version":3,"sources":["../../src/shell.js","../../src/console.jsx","App.js","serviceWorker.js","index.js"],"names":["BUILTINS","ver","process","require","help","commands","cmds","Set","Object","context","executables","Array","variables","this","get","set","date","type","v","sleep","n","Promise","r","setTimeout","echo","a","cast","t","toString","length","json","JSON","range","grep","re","RegExp","e","index","variable","options","o","getVariable","oldVal","newVal","setVariable","eval","tokens","tokenise","input","statements","parse","run","alert","CONTROL","OPERATORS","constructor","output","error","executeStatements","i","statement","items","loopVar","originalItem","start","iteration","doneIndex","s","Error","forLoop","executeStatementOperator","self","originalContext","promise","executeStatement","result","value","String","left","right","isDate","dateCalc","args","arg","evaldArgs","command","executeCommand","name","matchers","regex","text","tail","done","match","m","val","repeat","splitTokens","parseStatementOperators","background","prev","curr","operator","joinStatementOperators","makeNode","parseStatement","pipes","end","item","str","joinPipes","out","current","isNotNull","isNull","d","Date","ConsoleDisplay","shell","style","onClose","React","inputRef","shellRef","outerRef","backgroundColor","setTextColor","setBackgroundColor","exit","clear","setHist","hist","handleSubmit","setInput","setScrollback","pushHist","setExecuting","divStyle","color","className","classes","ref","onClick","getSelection","key","l","onSubmit","executing","disabled","onChange","onKeyUp","inputHist","h","nextScrollback","Math","scrollback","isNaN","onKeyDown","autoFocus","demo","execute","App","Boolean","window","location","hostname","ReactDOM","render","StrictMode","document","getElementById","navigator","serviceWorker","ready","then","registration","unregister","catch","console","message"],"mappings":"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","file":"static/js/main.dcb5462d.chunk.js","sourcesContent":["const BUILTINS = {\r\n    ver: () => process.env.REACT_APP_COMMIT_HASH || require('../package.json').version,\r\n    help: () => `Command Interpreter version ${BUILTINS['ver']()}\\n© Iain MacDonald\\n\\nBuiltin commands:\\n${BUILTINS['commands']().join(\"\\n\")}`,\r\n    commands: getCommands,\r\n    variables () { return this.context.variables }, // Not fat arrow, so `this` can be used\r\n    get: getVariable,\r\n    set: setVariable,\r\n    date: () => new Date(),\r\n    type: v => v instanceof Date ? \"date\" : (Array.isArray(v) ? \"list\" : (v === null ? \"\": typeof v)),\r\n    sleep: n => new Promise(r => setTimeout(r, n * 1000)),\r\n    echo: (...a) => a.flat().filter(isNotNull).map(toString).join(\" \"),\r\n    cast: (v,t) => {\r\n        if (t === \"number\") return +v;\r\n        if (t === \"string\") return toString(v);\r\n        if (t === \"list\" && typeof v === \"string\") return v.split(\"\\n\");\r\n        return v;\r\n    },\r\n    length: v => (Array.isArray(v) ? v : (typeof v === \"string\" ? v.split(\"\\n\") : [v])).length,\r\n    json: (...a) => a.length === 0 ? null : (a.length === 1 ? JSON.stringify(a[0]) : JSON.stringify(a)),\r\n    range: n => Array(n).fill(0).map((n,i) => i),\r\n    grep: (a, r) => {\r\n        try{\r\n            const re = new RegExp(r);\r\n            return a.filter(v => re.test(v));\r\n        } catch (e) {\r\n            return a.filter(v => v.includes(r));\r\n        }\r\n    },\r\n    index: (a, i) => a[i],\r\n    async tee (value, ...options) {\r\n        const variable = options.find(o => !o.startsWith(\"-\")) || \"output\";\r\n        const append = options.some(o => o === \"-a\");\r\n        if (append) {\r\n            const oldVal = await getVariable.call(this, variable) || [];\r\n            const newVal = Array.isArray(oldVal) ? oldVal : [ oldVal ];\r\n            newVal.push(value);\r\n            setVariable.call(this, variable, newVal);\r\n        } else {\r\n            setVariable.call(this, variable, value);\r\n        }\r\n        return value;\r\n    },\r\n    eval (...input) {\r\n        const tokens = tokenise(input.join(\" \"));\r\n        if (tokens.length === 0) return;\r\n        const statements = parse(tokens);\r\n        return run.call(this, statements[0]);\r\n    }\r\n};\r\n\r\nif (typeof alert !== \"undefined\") {\r\n    BUILTINS['alert'] = (...a) => alert(BUILTINS['echo'](...a));\r\n}\r\n\r\nconst CONTROL = [\"foreach\",\"done\"];\r\nconst OPERATORS = [\"+\",\"-\",\"*\",\"/\"];\r\n\r\nexport default class Shell {\r\n    constructor (context = {}) {\r\n        this.context = context;\r\n    }\r\n\r\n    /**\r\n     *\r\n     * @param {string} input\r\n     */\r\n    async execute (input, output=this.output, error=this.error) {\r\n        if (typeof this.context.variables === \"undefined\") {\r\n            this.context.variables = {};\r\n        }\r\n\r\n        this.output = output;\r\n        this.error = error;\r\n\r\n        try {\r\n            const tokens = tokenise(input);\r\n\r\n            if (tokens.length === 0) return;\r\n\r\n            const statements = parse(tokens);\r\n\r\n            await this.executeStatements(statements, output, error);\r\n        } catch (e) {\r\n            error(e.message);\r\n        }\r\n    }\r\n\r\n    /**\r\n     *\r\n     * @param {StatementNode[]} statements\r\n     * @param {(output: string) => void} output\r\n     * @param {(error: string) => void} error\r\n     */\r\n    async executeStatements(statements, output, error) {\r\n        const { variables } = this.context;\r\n\r\n        for (let i = 0; i < statements.length; i++) {\r\n\r\n            const statement = statements[i];\r\n            if (statement.control === \"foreach\") {\r\n                const items = BUILTINS['cast'](await run.call(this, statement.args[0]), \"list\");\r\n                const loopVar = statement.args[1] ? await run.call(this, statement.args[1]) : \"item\";\r\n                this.context.forLoop = {\r\n                    originalItem: variables[loopVar],\r\n                    start: i,\r\n                    items,\r\n                    iteration: 0,\r\n                    loopVar,\r\n                };\r\n\r\n                // TODO: this doesn't support nested loops\r\n                const doneIndex = statements.slice(i + 1).findIndex(s => s.control === \"done\");\r\n\r\n                if (doneIndex === -1) {\r\n                    throw Error(\"Unterminated foreach loop\");\r\n                }\r\n\r\n                if (items.length === 0) {\r\n                    i = doneIndex;\r\n                    continue;\r\n                }\r\n\r\n                variables[loopVar] = items[0];\r\n            }\r\n            else if (statement.control === \"done\") {\r\n                const { forLoop, variables } = this.context;\r\n\r\n                if (forLoop) {\r\n                    forLoop.iteration++;\r\n                    if (forLoop.iteration < forLoop.items.length) {\r\n                        i = forLoop.start;\r\n                        variables[forLoop.loopVar] = forLoop.items[forLoop.iteration];\r\n                    }\r\n                    else {\r\n                        if (typeof forLoop.originalItem === \"undefined\") {\r\n                            delete variables[forLoop.loopVar];\r\n                        }\r\n                        else {\r\n                            variables[forLoop.loopVar] = forLoop.originalItem;\r\n                        }\r\n                        this.context.forLoop = null;\r\n                    }\r\n                }\r\n                else {\r\n                    throw Error(`Unexpected control word: ${statement.control}`);\r\n                }\r\n            }\r\n            else {\r\n                await this.executeStatementOperator(statement, output, error);\r\n            }\r\n        }\r\n    }\r\n\r\n    async executeStatementOperator (statement, output, error) {\r\n        let promise;\r\n        const self = this;\r\n        const originalContext = this.context;\r\n        // capture context\r\n        // bug fix from foreach loop e.g.\r\n        //      range 10 | foreach; sleep $item && echo $item &; done\r\n        const context = { ...originalContext, variables: { ...originalContext.variables } };\r\n\r\n        if (statement.operator === \"&&\") {\r\n            promise = this.executeStatementOperator(statement.left, output, error).then(() => {\r\n                self.context = context;\r\n                return self.executeStatementOperator(statement.right, output, error).then(() => {\r\n                    self.context = originalContext;\r\n                });\r\n            });\r\n        } else {\r\n            promise = this.executeStatement(statement, output, error);\r\n        }\r\n\r\n        if (statement.background) {\r\n            promise.catch(e => { throw e; });\r\n        } else {\r\n            await promise;\r\n        }\r\n    }\r\n\r\n    async executeStatement(statement, output, error) {\r\n        const { variables } = this.context;\r\n\r\n        try {\r\n            const result = await run.call(this, statement);\r\n            output(toString(result));\r\n            variables[0] = result;\r\n        }\r\n        catch (e) {\r\n            error(e.message);\r\n        }\r\n    }\r\n}\r\n\r\n/**\r\n *\r\n * @param {any} value\r\n * @returns {string}\r\n */\r\nfunction toString (value) {\r\n    if (typeof value === \"undefined\" || value === null) return \"\";\r\n    if (value instanceof Date) return value.toISOString();\r\n    if (Array.isArray(value)) return value.map(toString).join(\"\\n\");\r\n    if (typeof value === \"object\") return Object.entries(value).map(([n,v]) => `${n} = ${toString(v)}`).join(\"\\n\");\r\n    return String(value);\r\n}\r\n\r\nasync function run (statement) {\r\n    if (typeof statement !== \"object\") return statement;\r\n\r\n    // e.g. $$variable\r\n    if (typeof statement.variable === \"object\") return getVariable.call(this, await run.call(this, statement.variable));\r\n\r\n    if (typeof statement.variable === \"string\") return getVariable.call(this, statement.variable);\r\n\r\n    if (typeof statement.operator === \"string\") {\r\n        if (statement.operator === \"=\")\r\n            return setVariable.call(this, statement.name, await run.call(this, statement.value));\r\n\r\n        const left = await run.call(this, statement.left);\r\n        const right = await run.call(this, statement.right);\r\n\r\n        if (isDate(left) || isDate(right)) {\r\n            return dateCalc(statement.operator, left, right);\r\n        }\r\n\r\n        // eslint-disable-next-line\r\n        switch (statement.operator) {\r\n            case \"+\": return left + right;\r\n            case \"-\": return left - right;\r\n            case \"*\": return left * right;\r\n            case \"/\": return left / right;\r\n        }\r\n\r\n        throw Error(`Unrecognised operator: ${statement.operator}`);\r\n    }\r\n\r\n    let { command, args } = statement;\r\n\r\n    const evaldArgs = await Promise.all(args.map(arg => {\r\n        if (typeof arg === \"object\") {\r\n            return run.call(this, arg);\r\n        }\r\n\r\n        return arg;\r\n    }));\r\n\r\n    if (command in BUILTINS) {\r\n        return BUILTINS[command].call(this, ...evaldArgs);\r\n    }\r\n\r\n    return executeCommand.call(this, command, evaldArgs);\r\n};\r\n\r\nasync function getVariable (name) {\r\n    let { context } = this;\r\n\r\n    // Descend through contexts\r\n    // deeper and deeper into each parent until we find variable\r\n    while (context) {\r\n        const { executables = {}, variables = {} } = context;\r\n\r\n        if ('get' in executables) {\r\n            try {\r\n                const result = await executables.get(name);\r\n                return result;\r\n            } catch (e) {}\r\n        }\r\n\r\n        if (name in variables) return variables[name];\r\n\r\n        context = context.parent;\r\n    }\r\n\r\n    // special cases\r\n    if (name === \"commands\") return BUILTINS['commands'].call(this);\r\n    if (name === \"variables\") return [...Object.keys(this.context.variables), \"commands\", \"variables\"];\r\n}\r\n\r\nasync function setVariable (name, value) {\r\n    let { context } = this;\r\n\r\n    // Descend through contexts\r\n    // deeper and deeper into each parent until we find variable\r\n    while (context) {\r\n        const { executables = {}, variables = {} } = context;\r\n\r\n        if ('set' in executables) {\r\n            try {\r\n                const result = await executables.set(name, value);\r\n                return result;\r\n            } catch (e) {}\r\n        }\r\n\r\n        if (name in variables) {\r\n            try {\r\n                variables[name] = value;\r\n                return value;\r\n            } catch (e) {\r\n                throw Error(`${name} is readonly`);\r\n            }\r\n        }\r\n\r\n        context = context.parent;\r\n    }\r\n\r\n    // If we're here we got to the deepest context without finding the variable\r\n    // we're just going to set it on the highest context\r\n    try {\r\n        this.context.variables[name] = value;\r\n        return value;\r\n    } catch (e) {\r\n        throw Error(`${name} is readonly`);\r\n    }\r\n}\r\n\r\nasync function executeCommand (command, evaldArgs) {\r\n    let { context } = this;\r\n\r\n    while (context) {\r\n        const { executables = {} } = context;\r\n\r\n        if (command in executables) {\r\n            return executables[command].call(this, ...evaldArgs);\r\n        }\r\n\r\n        context = context.parent;\r\n    }\r\n\r\n    throw Error(`Command '${command}' not found`);\r\n}\r\n\r\nfunction getCommands () {\r\n    const cmds = new Set(Object.keys(BUILTINS));\r\n\r\n    let { context } = this;\r\n\r\n    // Descend through contexts\r\n    while (context) {\r\n        const { executables = {} } = context;\r\n\r\n        Object.keys(executables).forEach(cmds.add.bind(cmds));\r\n\r\n        context = context.parent;\r\n    }\r\n\r\n    return Array.from(cmds).sort();\r\n}\r\n\r\n/**\r\n *\r\n * @param {string} text\r\n * @returns {string[]}\r\n */\r\nfunction tokenise (text) {\r\n    const tokens = [];\r\n    let i = 0;\r\n\r\n    const matchers = [\r\n        {\r\n            name: \"whitespace\",\r\n            regex: /^\\s+/,\r\n            value: () => \"\",\r\n        },\r\n        {\r\n            name: \"string\",\r\n            regex: /^\"([^\"]*)\"/,\r\n            value: v => v.replace(/\\\\n/g, \"\\n\").replace(/\\\\t/g, \"\\t\"),\r\n        },\r\n        {\r\n            name: \"string_verbatim\",\r\n            regex: /^'[^']*'/,\r\n            value: v => v.replace(/\\\\n/g, \"\\n\").replace(/\\\\t/g, \"\\t\"),\r\n        },\r\n        {\r\n            name: \"num\",\r\n            regex: /^-?\\d+(?:\\.\\d+)?/,\r\n            value: v => +v,\r\n        },\r\n        {\r\n            name: \"variable\",\r\n            regex: /^\\$+\\w+/,\r\n        },\r\n        {\r\n            name: \"boolean\",\r\n            regex: /^(true|false)/,\r\n            value: v => v === \"true\",\r\n        },\r\n        {\r\n            name: \"punctuation\",\r\n            regex: /^(;|\\${|}|&&|[|=+*/&])/,\r\n        },\r\n        {\r\n            name: \"keyword\",\r\n            regex: /^(foreach|done)/,\r\n        },\r\n        {\r\n            name: \"name\",\r\n            regex: /^[\\w-]+/,\r\n        },\r\n    ]\r\n\r\n    while (i < text.length) {\r\n        const tail = text.substr(i);\r\n\r\n        let done = false;\r\n\r\n        for (const m of matchers) {\r\n            const match = m.regex.exec(tail);\r\n            if (match) {\r\n                let val = match[1] || match[0];\r\n\r\n                if (m.value instanceof Function) {\r\n                    val = m.value(val);\r\n                } else if (typeof m.value !== \"undefined\") {\r\n                    val = m.value;\r\n                }\r\n\r\n                if (typeof val !== \"undefined\" && val !== null && val !== \"\")\r\n                    tokens.push(val);\r\n\r\n                i += match[0].length;\r\n                done = true;\r\n                break;\r\n            }\r\n        }\r\n\r\n        if (!done) {\r\n            // Prompt   '> '\r\n            throw Error(`  ${\" \".repeat(i)}^\\nUnexpected input at ${i}: ${text.substr(i, 10)}`);\r\n        }\r\n    }\r\n\r\n    return tokens;\r\n}\r\n\r\n/**\r\n * @typedef StatementNode\r\n * @prop {string} [control]\r\n * @prop {string} [command]\r\n * @prop {StatementNode[]} [args]\r\n * @prop {string} [operator]\r\n * @prop {string|StatementNode} [name]\r\n * @prop {StatementNode} [variable]\r\n * @prop {string|StatementNode} [value]\r\n * @prop {string|StatementNode} [left]\r\n * @prop {string|StatementNode} [right]\r\n * @prop {boolean} [background]\r\n */\r\n\r\n/**\r\n *\r\n * @param {string[]} tokens\r\n * @returns {StatementNode[]}\r\n */\r\nfunction parse (tokens) {\r\n    const statements = splitTokens(tokens, \";\").map(parseStatementOperators);\r\n\r\n    return statements;\r\n}\r\n\r\n/**\r\n *\r\n * @param {string[]} tokens\r\n * @returns {StatementNode}\r\n */\r\nfunction parseStatementOperators (tokens) {\r\n    let background = false;\r\n\r\n    if (tokens[tokens.length-1] === \"&\") {\r\n        background = true;\r\n        tokens.length--;\r\n    }\r\n\r\n    const statements = splitTokens(tokens, \"&&\").map(parseStatement);\r\n\r\n    const statement = joinStatementOperators(statements);\r\n\r\n    statement.background = background;\r\n\r\n    return statement;\r\n}\r\n\r\n/**\r\n *\r\n * @param {*} items\r\n * @returns {StatementNode}\r\n */\r\nfunction makeNode (items) {\r\n    if (items.length === 3 && typeof items[0] === \"string\" && items[1] === \"=\") {\r\n        return {\r\n            operator: \"=\",\r\n            name: items[0],\r\n            value: items[2],\r\n        };\r\n    }\r\n\r\n    if (items.length === 3 && OPERATORS.includes(items[1])) {\r\n        return {\r\n            operator: items[1],\r\n            left: items[0],\r\n            right: items[2],\r\n        };\r\n    }\r\n\r\n    if (typeof items[0].variable !== \"undefined\") {\r\n        if (items.length > 1)\r\n            throw Error(\"Variable evaluation must be only node in statement\");\r\n        return items[0];\r\n    }\r\n\r\n    if (typeof items[0] === \"number\")\r\n        return items[0];\r\n\r\n    if (CONTROL.includes(items[0])) {\r\n        const [control, ...args] = items;\r\n        return { control, args };\r\n    }\r\n\r\n    const [command, ...args] = items;\r\n    return { command, args };\r\n}\r\n\r\n/**\r\n *\r\n * @param {string[]} tokens\r\n * @returns {StatementNode}\r\n */\r\nfunction parseStatement (tokens) {\r\n    const pipes = [];\r\n\r\n    let items = [];\r\n\r\n    for (let i = 0; i < tokens.length; i++) {\r\n        const t = tokens[i];\r\n        if (t === \"|\") {\r\n            pipes.push(makeNode(items));\r\n            items = [];\r\n        }\r\n        else if (t === \"${\") {\r\n            const tail = tokens.slice(i+1);\r\n            const end = tail.indexOf(\"}\");\r\n            if (end === -1) throw Error(\"Unterminated sub-expression\");\r\n            items.push(parseStatement(tail.slice(0, end)));\r\n            i += end + 1;\r\n        }\r\n        else if (typeof t === \"number\") {\r\n            items.push(t);\r\n        }\r\n        else if (typeof t === \"string\" && t[0] === \"$\") {\r\n            let name = t.substr(1);\r\n            /** @type {{ variable: string|{ variable: string }}} */\r\n            let item = { variable: name };\r\n\r\n            // Only two levels deep for $$variables\r\n            if (name[0] === \"$\") {\r\n                item = {\r\n                    variable: {\r\n                        variable: name.substr(1),\r\n                    },\r\n                };\r\n            }\r\n\r\n            items.push(item);\r\n        }\r\n        else if (typeof t === \"string\" && t[0] === \"'\") {\r\n            const str = t.substr(1, t.length - 2);\r\n\r\n            items.push(str);\r\n        }\r\n        else items.push(t);\r\n    }\r\n\r\n    if (items.length === 0) throw Error(\"Empty pipe segment\");\r\n\r\n    pipes.push(makeNode(items));\r\n\r\n    const statement = joinPipes(pipes);\r\n\r\n    return statement;\r\n}\r\n\r\n/**\r\n *\r\n * @param {StatementNode[]} pipes\r\n * @returns {StatementNode}\r\n */\r\nfunction joinPipes(pipes) {\r\n    return pipes.reduce((prev, curr) => {\r\n        if (prev === null)\r\n            return curr;\r\n\r\n        // replace pipe-into-variable scenario with assignment\r\n        if (typeof curr.variable !== \"undefined\") {\r\n            return {\r\n                operator: \"=\",\r\n                name: curr.variable,\r\n                value: prev,\r\n            };\r\n        }\r\n\r\n        if (!curr.args) {\r\n            throw Error(`Unable to pipe to ${typeof curr}`);\r\n        }\r\n\r\n        curr.args.unshift(prev);\r\n\r\n        return curr;\r\n    }, null);\r\n}\r\n\r\n/**\r\n *\r\n * @param {StatementNode[]} statements\r\n * @returns {StatementNode}\r\n */\r\nfunction joinStatementOperators(statements) {\r\n    return statements.reduce((prev, curr) => {\r\n        if (prev === null)\r\n            return curr;\r\n\r\n        return {\r\n            operator: \"&&\",\r\n            left: prev,\r\n            right: curr,\r\n        };\r\n    }, null);\r\n}\r\n\r\n/**\r\n * @param {string[]} tokens\r\n * @param {string} separator\r\n * @returns {string[][]}\r\n */\r\nfunction splitTokens (tokens, separator) {\r\n    const out = [];\r\n    let current = [];\r\n    for (let i = 0; i < tokens.length; i++) {\r\n        if (tokens[i] === separator && current.length) {\r\n            out.push(current);\r\n            current = [];\r\n        } else current.push(tokens[i]);\r\n    }\r\n    if (current.length) out.push(current);\r\n    return out;\r\n}\r\n\r\n\r\nfunction isNull (v) {\r\n    return typeof v === \"undefined\" || v === null || v === \"\";\r\n}\r\n\r\nfunction isNotNull (v) {\r\n    return !isNull(v);\r\n}\r\n\r\nfunction isDate (d) {\r\n    return d instanceof Date;\r\n}\r\n\r\n/**\r\n * @param {string} operator\r\n * @param {number|Date} left\r\n * @param {number|Date} right\r\n */\r\nfunction dateCalc (operator, left, right) {\r\n    if (left instanceof Date && right instanceof Date) {\r\n        if (operator === \"-\") return +left - +right;\r\n        throw Error(\"Invalid date calc\");\r\n    }\r\n\r\n    if (operator !== \"+\") throw Error(\"Invalid date calc\");\r\n\r\n    return new Date(+left + +right);\r\n}","import React from 'react';\r\nimport Shell from './shell';\r\n\r\nimport classes from './console.css';\r\n\r\n/**\r\n * @param {object} props\r\n * @param {Shell} [props.shell]\r\n * @param {object} [props.context]\r\n * @param {React.CSSProperties} [props.style]\r\n * @param {() => void} [props.onClose]\r\n */\r\nexport default function ConsoleDisplay ({ shell = null, context = {}, style = {}, onClose = null }) {\r\n    const [ hist, setHist ] = React.useState([]);\r\n    const [ input, setInput ] = React.useState(\"\");\r\n    const [ scrollback, setScrollback ] = React.useState(0);\r\n    const [ executing, setExecuting ] = React.useState(false);\r\n    /** @type {React.MutableRefObject<HTMLInputElement>} */\r\n    const inputRef = React.useRef();\r\n    const shellRef = React.useRef(shell || new Shell(context));\r\n    /** @type {React.MutableRefObject<HTMLDivElement>} */\r\n    const outerRef = React.useRef();\r\n    const [ textColor, setTextColor ] = React.useState(style.color);\r\n    const [ backgroundColor, setBackgroundColor ] = React.useState(style.backgroundColor);\r\n\r\n    React.useEffect(() => {\r\n        context.parent = {\r\n            variables: {\r\n                textColor,\r\n                backgroundColor\r\n            },\r\n            executables: {\r\n                set (name, value) {\r\n                    if (name === \"textColor\") return setTextColor(value);\r\n                    if (name === \"backgroundColor\") return setBackgroundColor(value);\r\n                    throw Error(\"Unhandled\");\r\n                },\r\n                exit: onClose || (() => {}),\r\n                clear: () => setHist([]),\r\n            },\r\n        };\r\n    }, [ context, textColor, setTextColor, backgroundColor, setBackgroundColor, onClose, setHist ]);\r\n\r\n    React.useEffect(() => {\r\n        inputRef.current && inputRef.current.focus();\r\n        outerRef.current && (outerRef.current.scrollTop = outerRef.current.scrollHeight);\r\n    }, [hist,executing]);\r\n\r\n    const handleSubmit = React.useCallback(e => {\r\n        function pushHist (newItem) {\r\n            setHist(hist => [ ...hist, newItem ]);\r\n        }\r\n\r\n        async function handleSubmit (e) {\r\n            e.preventDefault();\r\n\r\n            setInput(\"\");\r\n            setScrollback(0);\r\n            pushHist({ value: input, type: \"input\" });\r\n\r\n            if (shellRef.current) {\r\n                setExecuting(true);\r\n\r\n                await shellRef.current.execute(\r\n                    input,\r\n                    output => {\r\n                        pushHist({ value: output, type: \"output\" });\r\n                    },\r\n                    error => {\r\n                        pushHist({ value: error, type: \"error\" });\r\n                    }\r\n                );\r\n\r\n                setExecuting(false);\r\n            } else {\r\n                pushHist({ value: \"No interpreter specified\", type: \"error\" });\r\n            }\r\n        }\r\n\r\n        handleSubmit(e);\r\n    }, [input, setInput, setScrollback, setHist, setExecuting]);\r\n\r\n    /**\r\n     *\r\n     * @param {React.KeyboardEvent<HTMLInputElement>} e\r\n     */\r\n    function handleKeyUp (e) {\r\n        const inputHist = hist.filter(h => h.type === \"input\" && h.value);\r\n        let nextScrollback = NaN;\r\n\r\n        if (e.key === \"ArrowUp\") {\r\n            nextScrollback = Math.min(scrollback + 1, inputHist.length);\r\n        }\r\n        else if (e.key === \"ArrowDown\") {\r\n            nextScrollback = Math.max(scrollback - 1, 0);\r\n        }\r\n\r\n        if (!isNaN(nextScrollback)) {\r\n            setScrollback(nextScrollback);\r\n\r\n            if (nextScrollback === 0 && scrollback !== 0) {\r\n                setInput(\"\");\r\n            } else if (nextScrollback !== 0) {\r\n                setInput(inputHist[inputHist.length - nextScrollback].value);\r\n            }\r\n        }\r\n    }\r\n\r\n    const divStyle = {...style, color: textColor, background: backgroundColor };\r\n\r\n    return (\r\n        <div className={classes.ConsoleDisplay} ref={outerRef} onClick={() => getSelection().type !== \"Range\" && inputRef.current.focus()} style={divStyle}>\r\n            <ul>{ hist.map((l,i) => <li key={i} className={classes[`ConsoleDisplay-hist-${l.type}`]}>{l.value}</li>) }</ul>\r\n            <form onSubmit={handleSubmit}>\r\n                { !executing && '> ' }\r\n                <input\r\n                    value={input}\r\n                    ref={inputRef}\r\n                    disabled={executing}\r\n                    onChange={e => setInput(e.target.value)}\r\n                    onKeyUp={handleKeyUp}\r\n                    // prevent cursor from jumping to beginning of line\r\n                    onKeyDown={e => e.key === \"ArrowUp\" && e.preventDefault()}\r\n                    autoFocus\r\n                />\r\n            </form>\r\n        </div>\r\n    );\r\n}","import React from 'react';\nimport './App.css';\nimport { Console } from 'app-console';\n\nimport \"app-console/dist/index.css\";\n\nconst demoScript = `\necho Welcome to the demo \"script.\";\nsleep 1;\necho Sit back and watch some sample commands;\nsleep 1;\necho executed before your \"eyes!\";\nsleep 1;\necho \">\" date;\ndate;\nsleep 1;\necho \">\" sleep 3;\nsleep 3;\necho \">\" date;\ntee \\${date} d;\nsleep 1;\necho \">\" echo '$0';\necho $d;\nsleep 1;\necho \">\" 5 + 2;\n5 + 2;\nsleep 1;\necho \">\" a = '\\${6 * 2}';\na = \\${6 * 2};\nsleep 1;\necho \">\" echo Answer is '$a';\necho Answer is $a;\nsleep 1;\necho \">\" range 3;\nrange 3;\nsleep 1;\necho \">\" '$0 | json';\nrange 3 | json;\nsleep 1;\necho '> range 50 | grep 7' ;\nrange 50 | grep 7;\nsleep 1;\necho '> foreach \\${range 10}; sleep 1; $item; done;';\nforeach \\${range 10}; sleep 1; $item; done;\necho ' ';\necho 'Thanks!';\n`;\n\nconst executables = {\n  demo () {\n    return this.execute(demoScript);\n  },\n};\n\nfunction App() {\n  return (\n    <div className=\"App\">\n      <p>Type demo or help to get started.</p>\n      <Console context={{ executables }} />\n    </div>\n  );\n}\n\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' },\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready\n      .then(registration => {\n        registration.unregister();\n      })\n      .catch(error => {\n        console.error(error.message);\n      });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}